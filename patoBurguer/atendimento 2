#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include "cardapio.h"
#include "fila.h"
#include "pilha.h"


typedef struct {
    char nome[50];
    int quantidade;
    float precoCompra;
} IngredienteEstoque;

typedef struct NoIngred {
    char nome[50];
    int totalConsumido;
    struct NoIngred *esq, *dir;
} NoIngred;

void inicializaEstoque(IngredienteEstoque estoque[], int *n) {
    *n = 8;
    strcpy(estoque[0].nome, "Pao");     estoque[0].quantidade = 50; estoque[0].precoCompra = 0.50f;
    strcpy(estoque[1].nome, "Carne");   estoque[1].quantidade = 40; estoque[1].precoCompra = 2.00f;
    strcpy(estoque[2].nome, "Bacon");   estoque[2].quantidade = 30; estoque[2].precoCompra = 1.00f;
    strcpy(estoque[3].nome, "Queijo");  estoque[3].quantidade = 40; estoque[3].precoCompra = 0.80f;
    strcpy(estoque[4].nome, "Alface");  estoque[4].quantidade = 60; estoque[4].precoCompra = 0.30f;
    strcpy(estoque[5].nome, "Tomate");  estoque[5].quantidade = 50; estoque[5].precoCompra = 0.40f;
    strcpy(estoque[6].nome, "Molho");   estoque[6].quantidade = 40; estoque[6].precoCompra = 0.25f;
    strcpy(estoque[7].nome, "Cebola");  estoque[7].quantidade = 30; estoque[7].precoCompra = 0.20f;
}

int buscaIngredienteIndex(IngredienteEstoque estoque[], int n, const char *nome) {
    for (int i = 0; i < n; i++) {
        if (strcasecmp(estoque[i].nome, nome) == 0)
            return i;
    }
    return -1;
}

int consumirIngrediente(IngredienteEstoque estoque[], int n, const char *nome, int qtd) {
    int idx = buscaIngredienteIndex(estoque, n, nome);
    if (idx == -1) return 0;
    if (estoque[idx].quantidade < qtd) return 0;
    estoque[idx].quantidade -= qtd;
    return 1;
}

NoIngred* criaNo(const char *nome, int qtd) {
    NoIngred* novo = (NoIngred*) malloc(sizeof(NoIngred));
    strcpy(novo->nome, nome);
    novo->totalConsumido = qtd;
    novo->esq = novo->dir = NULL;
    return novo;
}

NoIngred* inserirNoConsumido(NoIngred *raiz, const char *nome, int qtd) {
    if (raiz == NULL) return criaNo(nome, qtd);
    int cmp = strcasecmp(nome, raiz->nome);
    if (cmp == 0)
        raiz->totalConsumido += qtd;
    else if (cmp < 0)
        raiz->esq = inserirNoConsumido(raiz->esq, nome, qtd);
    else
        raiz->dir = inserirNoConsumido(raiz->dir, nome, qtd);
    return raiz;
}

void imprimirInOrderConsumidos(NoIngred *raiz) {
    if (!raiz) return;
    imprimirInOrderConsumidos(raiz->esq);
    printf("%s : %d\n", raiz->nome, raiz->totalConsumido);
    imprimirInOrderConsumidos(raiz->dir);
}

void liberarArvore(NoIngred *raiz) {
    if (!raiz) return;
    liberarArvore(raiz->esq);
    liberarArvore(raiz->dir);
    free(raiz);
}

int pilhas_iguais(tp_pilha p1, tp_pilha p2) {
    if (p1.topo != p2.topo) return 0;
    for (int i = 0; i <= p1.topo; i++) {
        if (strcasecmp(p1.item[i], p2.item[i]) != 0)
            return 0;
    }
    return 1;
}

void atendimento_cliente(hamburguer *h) {
    printf("\nOii, tudo bem? Eu desejo um %s!\n", h->nome);
}

void montar_hamburguer_manual(hamburguer *h, IngredienteEstoque estoque[], int n, NoIngred **raiz_consumo, double *cofre) {
    atendimento_cliente(h);

    printf("\n-- Montando: %s --\n", h->nome);
    printf("Siga a ordem exata dos ingredientes.\n\n");

    printf("Receita (%d itens):\n", h->qntIngredientes);
    for (int i = 0; i < h->qntIngredientes; i++) {
        printf(" %d) %s\n", i + 1, h->ingredientes[i]);
    }

    tp_pilha pilha_correta, pilha_jogador;
    inicializa_pilha(&pilha_correta);
    inicializa_pilha(&pilha_jogador);

    for (int i = 0; i < h->qntIngredientes; i++) {
        char entrada[64];
        printf("\nIngrediente %d: ", i + 1);
        scanf(" %63[^\n]", entrada);

        push(&pilha_jogador, entrada);
        push(&pilha_correta, h->ingredientes[i]);

        if (strcasecmp(entrada, h->ingredientes[i]) != 0) {
            printf("-> Errado! Esperado: %s\n", h->ingredientes[i]);
        }

        if (!consumirIngrediente(estoque, n, h->ingredientes[i], 1)) {
            printf("-> Falta %s no estoque! Pedido cancelado.\n", h->ingredientes[i]);
            return;
        }

        *raiz_consumo = inserirNoConsumido(*raiz_consumo, h->ingredientes[i], 1);
    }

    if (pilhas_iguais(pilha_correta, pilha_jogador)) {
        printf("\nMontagem perfeita! Você ganhou R$ %.2f!\n", h->preco);
        *cofre += h->preco;
    } else {
        double metade = h->preco / 2.0;
        printf("\nMontagem incorreta! Você ganhou metade: R$ %.2f.\n", metade);
        *cofre += metade;
    }

    printf("Cofre atual: R$ %.2f\n", *cofre);
    printf("\nMontagem concluída!\n");
}

void atendimento_por_dias(hamburguer cardapio[], struct Fila *fila, IngredienteEstoque estoque[], int nEstoque, int dias) {
    NoIngred *raiz_consumo = NULL;
    double cofre = 0.0;
    srand(time(NULL));

    for (int dia = 1; dia <= dias; dia++) {
        printf("\n========== DIA %d ==========\n", dia);

        int novos = rand() % 5 + 1;
        for (int i = 0; i < novos; i++) {
            int idH = rand() % 10;
            enfileirar(fila, rand() % 1000, cardapio[idH].ID);
        }

        struct Pedido *p;
        while ((p = desenfileirar(fila)) != NULL) {
            int idx = p->idHamburguer - 1;
            if (idx < 0 || idx >= 10) {
                free(p);
                continue;
            }

            montar_hamburguer_manual(&cardapio[idx], estoque, nEstoque, &raiz_consumo, &cofre);
            free(p);
        }

        printf("\nDia %d encerrado. Cofre total: R$ %.2f\n", dia, cofre);
        printf("Pressione ENTER para continuar...\n");
        getchar();
    }

    printf("\n=== Ingredientes consumidos ===\n");
    imprimirInOrderConsumidos(raiz_consumo);
    liberarArvore(raiz_consumo);

    printf("\nTotal final no cofre: R$ %.2f\n", cofre);
}
